<!DOCTYPE html>
<html lang="en">
    <head>
        <title>NANDy - LithosphereRocketry</title><meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="pygmentize.css"> 
<link rel="stylesheet" href="styles.css"></head>
    <body>
        <div class="header">
    <span style="float: left;">
        <a href="/">Home</a>
        <a href="/projects.html">Projects</a>
    </span>
    <span style="float: right;">
        <a href="https://github.com/LithosphereRocketry/LithosphereRocketrySiteSource">Source</a>
    </span>
</div><div class="article-body">
            <h1 id="nandy">NANDy</h1>
<p>Some time ago, I was idly playing around with digital logic and remembered
something that seemed to be part of every piece of computer-engineering
educational material: you can make any logical device out of NAND gates.
(As an aside, NOR gates can do the same thing; I don't know why they don't get
talked about as much. Heck, a computer made entirely out of NOR gates landed us
on the moon.)</p>
<p>I decided to take a look at what it would take to implement an entire basic CPU
using only standard off-the-shelf NAND gates. It turns out, this is a very bad
idea.</p>
<p>Before we get too far into the weeds, I set some general ground rules and goals
for this project:</p>
<ul>
<li>The CPU itself will be entirely NAND gates. That's kind of the whole point
  of the project.</li>
<li>Any part which is strictly a NAND gate is permitted. This includes gates with
  any number of input pins as well as open-collector and other gate types.
  Schmitt-trigger gates are an interesting gray area, since they technically
  contain memory elements and therefore could be considered not just gates, but
  I don't plan to use any anyway, so it doesn't really matter.</li>
<li>Parts that are not the CPU are not restricted to NAND gates. I briefly
  considered building RAM and ROM out of gates, but it gets extremely tedious
  extremely quickly for any useful amount of storage. Additionally, clock
  generators and other support components can be built however I like. However,
  I won't push this limit; integrated memory chips will be used only for things
  that are fundamentally memory, and not dubious cases like microcode ROMs.</li>
<li>Peripheral devices don't have to be NAND gates, but it's more fun if they are.
  My general game plan is to implement these parts on an FPGA and then transfer
  them to dedicated ICs if they're simple enough.</li>
</ul>
<h2 id="basics">Basics</h2>
<p>Our building block for the project, for the most part, is going to be this:</p>
<p><img alt="Integrated circuit marked with code 74AC00P" src="media/nandy/7400.jpg"></p>
<p>This is about the most standard NAND gate you can get. It's a 4-module, 2-input
CMOS gate compatible with 5V logic levels; the AC in the part number indicates
that it's fairly fast, and most importantly it is very inexpensive in decent
quantities.</p>
<p>As the theorem states, we can build any combinational logic we want out of
these. Here's an XOR gate and a 1-bit full adder:</p>
<p><img alt="Schematic of XOR gate and full adder implemented using NAND gates, with
equivalent symbols alongside them" src="media/nandy/combinational.png"></p>
<p>Building elements that have memory is a bit trickier, and a bit less elegant.
Because memory elements tend to depend on themselves, they don't lend themselves
well to concise mathematical representations, instead relying on timing and
implementation details. Latches - components that allow their contents to change
continuously whenever their clock signal is high - aren't too bad:</p>
<p><img alt="Schematic of D latch implemented using NAND gates" src="media/nandy/dlatch.png"></p>
<p>Flip-flops - elements that can instantaneously sample a signal on the rising or
falling edge of the clock - are a bit more difficult. While it's possible to
build a functioning CPU without these components, it's a bit more difficult;
generally, it requires a two-phase clock or other similar strategy. </p>
<p>Wikipedia gives an example of a D flip-flop that looks like this:</p>
<p><img alt="A D flip flop design made from 6 NAND gates, structured as 3 RS latches" src="media/nandy/dff_wikipedia.png"></p>
<p><em>By Nolanjshettle at English Wikipedia, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=40852354</em></p>
<p>This design works great - and I originally planned to use it, and even got as
far as prototyping some components using it - but it's not actually that useful
for my purposes. The main issue is that it doesn't have a write-enable input, so
retaining a value for more than one clock cycle requires either multiplexing the
output back into the input or doing a significant amount of tearing-apart of the
internal logic, either of which adds a lot of component cost. Instead, I went
with a design that looks like this:</p>
<p><img alt="A D flip flop design made from 9 NAND gates, structured as a pulse generator and D latch" src="media/nandy/dff_mine.png"></p>
<p>This is, to be brutally honest, a fairly ugly solution. You may notice that it's
just a D latch as above, but with a weird piece of combinational logic for the
write signal; this logic computes the expression (CLK and not (not (not CLK))),
which is almost always 0. When clock gate switches high, it takes about 30
nanoseconds for the signal to propagate through all of those inverters, so as
long as the input doesn't change for those 30 nanoseconds it'll write correctly.
There's nothing else in the computer that's remotely that fast, so this works
great. An added bonus is that the edge-detector structure can be shared across
all the bits of the same register, so it only has to be implemented once instead
of 8 times; technically, only one edge detector is needed for the whole computer,
but I figured relying on a high-speed pulse like that to stay intact across that
distance was asking for trouble, so one per register it is.</p>
<h2 id="the-architecture">The Architecture</h2>
<p>For the architecture of this CPU, I went through quite a few iterations before
settling on a final design - in my own notes, the current design is referred to
as "architecture 4.5." The design takes a lot of impsiration from the MOS 6502,
with an X and Y index register, accumulator, and 256-byte stack. However,
compared to other 8-bit-era processors, it's a lot more RISC-ish: no indirect
arithmetic operations, only separate loads and stores.</p>
<p>The core specs of the machine currently look something like this:</p>
<ul>
<li>1 MHz processor clock</li>
<li>32KB ROM, 32KB RAM (256 bytes usable as stack) </li>
<li>1 hardware interrupt</li>
<li>Function calling with reentrancy and recursion (at least until you run out of
   stack)</li>
<li>Power consumption: about 10 watts projected (mostly LEDs)</li>
</ul>
<p>To help ease the pain of having so few registers, there are also a collection of
swap instructions, which instantaneously exchange any register with the
accumulator. Then, instead of the 6502's <code>inx</code> to increment X, we do
<code>sw x; addi 1; sw x</code>. The main motivation for this increase in code complexity
was to reduce the number of states required for instruction execution; no
instruction takes more than 2 cycles, and a large quantity (basically, anything
that doesn't require extra memory accesses) only requires one.</p>
<p>The one exception to the "arithmetic only happens on the accumulator" rule is
the increment-stack-pointer operation. This is because the processor supports
interrupts for I/O, and interrupts assume the stack to be in good working order;
to implement <code>isp</code> from swaps would have to take up 5 instructions:</p>
<div class="codehilite"><pre><span></span><code>dint      # Disable interrupts
sw sp
addi -3
sw sp
eint      # Enable interrupts
</code></pre></div>

<p>That's not even to mention that you might want to increment the stack pointer
when interrupts were already disabled, so it can't even be made into a nice
handy macro. With the way the cost and complexity of this project have gradually
expanded, part of me still thinks it would have been worth doing, but at this
stage it's not really something I want to mess with.</p>
<p>One place I did accept a bit of clunkiness to reduce the instruction set was in
procedure calls. NANDy supports relative jumps - i.e. "go to 327 bytes after the
current instruction" - both with and without boolean conditions, but procedure
calls - i.e. "go to this location, and store my previous location for future
use" - must be done by loading the X and Y registers with an exact address:</p>
<div class="codehilite"><pre><span></span><code><span class="n">wr</span><span class="w"> </span><span class="n">dy</span><span class="w">    </span><span class="p">#</span><span class="w"> </span><span class="n">Stash</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="n">register</span><span class="w"></span>
<span class="n">rdi</span><span class="w"> </span><span class="mh">0</span><span class="n">x12</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="n">Load</span><span class="w"> </span><span class="n">lower</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">address</span><span class="w"></span>
<span class="n">wr</span><span class="w"> </span><span class="n">dx</span><span class="w">    </span><span class="p">#</span><span class="w"> </span><span class="n">Put</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">lower</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">register</span><span class="w"></span>
<span class="n">rdi</span><span class="w"> </span><span class="mh">0</span><span class="n">x34</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="n">Load</span><span class="w"> </span><span class="n">upper</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">address</span><span class="w"></span>
<span class="n">sw</span><span class="w"> </span><span class="n">dy</span><span class="w">    </span><span class="p">#</span><span class="w"> </span><span class="n">Put</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">upper</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">register</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="kt">time</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="n">our</span><span class="w"> </span><span class="n">original</span><span class="w"></span>
<span class="w">         </span><span class="p">#</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">back</span><span class="w"></span>
<span class="n">jar</span><span class="w">      </span><span class="p">#</span><span class="w"> </span><span class="n">Jump</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="k">function</span><span class="w"></span>
</code></pre></div>

<p>Luckily, since this is all register-juggling and doesn't use the stack, it can
be neatly wrapped up in a macro:</p>
<div class="codehilite"><pre><span></span><code>call func
</code></pre></div>

<h2 id="the-datapath">The Datapath</h2>
<p>After a large amount of iteration and rearranging, I ended up with a datapath
that looks something like this:</p>
<p><img alt="High-level diagram of processor datapath" src="media/nandy/datapath.png"></p>
<p>This is somehow simultaneously a bit of a rat's nest and restrictively simple.
Let's take a look at how a few relevant instructions pass through the datapath:</p>
<p>The simplest thing that it's possible to do on the processor is a no-operation,
abbreviated <code>nop</code>. On a CPU, the task of "doing nothing" typically entails two
steps: loading the nop instruction itself from memory, and incrementing the
program counter to point to the next instruction. In the NANDy datapath, those
steps occur via the green and blue paths here respectively:</p>
<p><img alt="Processor datapath with fetch and PC-increment paths highlighted" src="media/nandy/datapath-nop.png"></p>
<p>This same fetch-and-advance structure is present in almost all instructions. For
example, adding the X register to the accumulator looks like this, with the
actual operation occurring via the red path:</p>
<p><img alt="Processor datapath with fetch, PC-increment, and arithmetic paths highlighted" src="media/nandy/datapath-add.png"></p>
<p>By looking at the datapath here, we can see why I was a little salty about not
being able to easily replace the separate <code>isp</code> operator with other operations.
There are three whole multiplexers here whose sole job is to implement the <code>isp</code>
operation. Yuck. Who knows, I may end up going to the manual solution that I
said was too complex originally after all.</p>
<p><img alt="Processor datapath with increment-stack-pointer path highlighted, with arrows to three multiplexers used" src="media/nandy/datapath-isp.png"></p>
<h2 id="the-io-dilemma">The I/O Dilemma</h2>
<p>Originally, I designed the processor around a single 8-bit input-output port.
This made a lot of sense when I first started developing the project; originally
I had planned for the processor to be a lot more primitive, with only one index
register instead of two and only 256 bytes of RAM. However, feature-creep got 
the best of me, and I ended up designing something that might be capable of more
complex tasks, which necessitated more complex I/O.</p>
<p>This left me at a bit of a dilemma: I had already designed the instruction set
to support only a single I/O port, but for most of the end goals I had for this
architecture, I would need more ports. The options I considered were:</p>
<ol>
<li>Keep the I/O design exactly as is, and require every I/O request to contain
   a prefix indicating the device to target and possibly how many bytes to send
   to that device.</li>
<li>Keep the I/O design exactly as is, and consider each I/O request to be a
   4-bit address followed by a 4-bit data value, or some other similar split.</li>
<li>Add a single-bit chip-select output that is controlled by dedicated
   instructions; when chip-select is active, I/O writes set the device address
   to be used in the next operation.</li>
<li>Keep the I/O design mostly as is, but reuse one of the index registers as an
   I/O address register.</li>
<li>Ditch the I/O register entirely, and make I/O either part of the memory space
   (<em>a la</em> 6502) or its own pseudo-memory space (<em>a la</em> Z80).</li>
</ol>
<p>I fairly quickly narrowed down the options to 3, 4, and 5; most of the devices I
want to use take an 8-bit input, and having the external logic to distinguish
prefixes from device data would add a whole lot of complexity that I don't want
to deal with.</p>
<h2 id="picking-a-goal">Picking a Goal</h2>
<p>As the feature creep started to build up on this project, I realized I really
needed to settle on a goal to keep this from dragging on forever. Originally, I
had planned on trying to make it play Tetris, but I eventually decided against
that, mostly for interfacing reasons - either I'd need a full-featured graphical
output, which would be expensive and complicated, or I'd need to build a 
specific made-for-purpose Tetris board display, which wouldn't be very
interesting. I also considered a couple other options:</p>
<ul>
<li>IRC client via old-school serial modem - requires learning a lot of different
  protocols, and networking things never work</li>
<li>Scientific calculator - requires floating-point and/or high-precision math</li>
<li>Lisp interpreter - this one is pretty plausible; the only limitation is that
  deep recursion requires some extra thought when you only have 256 bytes of
  stack</li>
<li>Full-fledged DOS-style prompt - this would be a lot of fun, but also a <em>lot</em>
  of added scope</li>
</ul>
<p>In the end, the thing that convinced me was someone recommending that I try the
classic text adventure Planetfall. Planetfall and the other Infocom games are
especially interesting in that they may be the first games written using an
engine and virtual machine, rather than direcly to assembly. Infocom games were
written in a human-readable, Lisp-like language called ZIL, then compiled to a
virtual-machine bytecode called Z-Machine. This means that any computer that can
interpret Z-Machine bytecode can in theory run any Infocom game. Being a text
adventure, I/O can just be a serial port, and the command set was simple enough
to implement on 8-bit computers of the time like the Atari and Commodore 64.
Perfect for my minimal CPU!</p><a href="#">Back to Top</a>
        </div>
    </body>
</html>